#### 一、死锁产生情况截图

修改count为11000，在第22次循环时陷入死锁。

![这里写图片描述](http://img.blog.csdn.net/20161017224557924)

####二、死锁产生条件
- **资源互斥：资源始终只能被一个线程持有。**
- **持有并等待：一个线程持有一个资源，但是它依然等待着被其他线程所持有的资源。**
- **循环等待：假设有Pn个线程，p0请求的资源被P1所持有，P1请求的资源被P2所持有，...，Pn请求的资源被P0所持有。**
- **资源无法被抢占。**

####三、死锁产生解释
　　t这个线程在runnable构造函数中被声明，当它调用成员函数start的时候，就被插入到调度队列里，本例子中，就是直接开始运行run()，而且是在后台运行，相当于和main函数代表的主线程并行执行，因此可以把关注点放在t.start()之后并行执行的main函数和run函数上。
　　run函数中，直接执行b.methodB(a)，这实际上是b调用methodB()之后再调用a.last()的过程。
　　main函数中，先是一个while循环，可以看做一个延时，这个延时跟电脑的各个因素有关，所以同一个时间在不同电脑上的count可能不同，甚至两次运行用的时间都不同。在这一段延时之后，开始执行a.methodA(b)，所以main函数实际上是一段延时后，a调用methodA()之后再调用b.last()的过程。
　　根据死锁的产生条件可以知道，一定有一个线程拥有A资源，并且请求B资源，另一个线程拥有B资源，请求A资源，两边都不放手，只能陷入死锁。
　　run函数不延时，我们猜测它先执行b.methodB()进入这个函数，接着打算请求A类的资源：a.last()，但是这个时候main函数延时结束，进入methodA()，相当于拥有了A资源，下一步打算请求B类资源：b.last()，因为b.methodB()属于B类资源，还握在run函数手中，所以主线程被阻塞，但是a.last()属于A类资源，还握在main函数手中，所以线程t被阻塞，死锁因此发生。
　　while延时在制造死锁中起到的作用就是让主线程进入methodA()函数的时候t线程已经进入methodB()，且没有来得及执行a.last()。
